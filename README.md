# c++ -
### 指针常量和常量指针
```c++
int a =3;
int b = 1;
int c = 2;
int const *p1 = &b;//const 在前，定义为常量指针
int *const p2 = &c;//*在前，定义为指针常量 
```
**常量指针p1**：指向的地址可以变，但内容不可以重新赋值，内容的改变只能通过修改地址指向后变换。

p1 = &a是正确的，但 *p1 = a是错误的。

**指针常量p2**：指向的地址不可以重新赋值，但内容可以改变，必须初始化，地址跟随一生。

p2= &a是错误的，而*p2 = a 是正确的。

### const
const 加在成员函数后面表示该函数不会修改任何数据成员

### dynamic_cast
dynamic_cast在将父类cast到子类时，父类必须要有虚函数，否则编译器会报错。

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；

在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

当dynamic_cast进行下行转换时，若转换对象实际指向父类指针，则报错bad_cast返回NULL

### 重写，重载，重定义

- 重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。

- 重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。

- 重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override)

### 左值，右值

- 左值 (lvalue, locator value) 表示了一个占据内存中某个可识别的位置（也就是一个地址）的对象。

- 右值 (rvalue) 则使用排除法来定义。一个表达式不是 左值 就是 右值 。 那么，右值是一个 不 表示内存中某个可识别位置的对象的表达式。


### ++i,i++

i++ 与 ++i 的主要区别有两个：

1. i++ 返回原来的值，++i 返回加1后的值。
2. i++ 不能作为左值，而++i 可以。

```c++
// 前缀形式：
int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用
{//函数本身无参，意味着是在自身空间内增加1的
  *this += 1;  // 增加
  return *this;  // 取回值
}

//后缀形式:
const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。
{//函数带参，说明有另外的空间开辟
  int oldValue = *this;  // 取回值
  ++(*this);  // 增加
  return oldValue;  // 返回被取回的值
}
```

### 内存分配
1. 栈区（stack）— 由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈，栈地址是向下增长的。
2. 堆区（heap） — 一般由程序员分配释放，若程序员不释放，程序结束时可能由OS（操作系统）回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放。
4. 文字常量区 —常量字符串就是放在这里的。程序结束后由系统释放。
5. 程序代码区—存放函数体的二进制代码。

**线程共享堆，但是每个线程有自己的寄存器和栈**

```c++
int  a=0;   全局初始化区    
char *p1;   全局未初始化区    
int  main()    
{    
  int  b; //栈    
  char  s[]="abc"; //栈    
  char  *p2; //栈    
  char  *p3="123456"; //123456/0在常量区，p3在栈上。    

  static int c =0；//全局（静态）初始化区    
  p1 =  (char  *)malloc(10);  //分配得来得10和20字节的区域就在堆区
  p2  = (char  *)malloc(20);       
  strcpy(p3,"123456"); //123456/0放在常量区，编译器可能会将它与p3所指向的"123456"  优化成一个地方。    
}  
```


```c++
void f() { int* p=new int[5]; }
```
看到 new，我们首先就应该想到，我们分配了一块堆内存，那么指针 p 呢？他分配的是一块栈内存


### 数组的特点
- 在内存中，数组是一块连续的区域。 拿上面的看电影来说，这几个人在电影院必须坐在一起。
- 数组需要预留空间，在使用前要先申请占内存的大小，可能会浪费内存空间。 比如看电影时，为了保证10个人能坐在一起，必须提前订好10个连续的位置。这样的好处就是能保证10个人可以在一起。但是这样的缺点是，如果来的人不够10个，那么剩下的位置就浪费了。如果临时有多来了个人，那么10个就不够用了，这时可能需要将第11个位置上的人挪走，或者是他们11个人重新去找一个11连坐的位置，效率都很低。如果没有找到符合要求的作为，那么就没法坐了。
- 插入数据和删除数据效率低，插入数据时，这个位置后面的数据在内存中都要向后移。删除数据时，这个数据后面的数据都要往前移动。 比如原来去了5个人，然后后来又去了一个人要坐在第三个位置上，那么第三个到第五个都要往后移动一个位子，将第三个位置留给新来的人。 当这个人走了的时候，因为他们要连在一起的，所以他后面几个人要往前移动一个位置，把这个空位补上。
随机读取效率很高。因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。
- 并且不利于扩展，数组定义的空间不够时要重新定义数组。

### 链表的特点
- 在内存中可以存在任何地方，不要求连续。 在电影院几个人可以随便坐。
- 每一个数据都保存了下一个数据的内存地址，通过这个地址找到下一个数据。 第一个人知道第二个人的座位号，第二个人知道第三个人的座位号……
- 增加数据和删除数据很容易。 再来个人可以随便坐，比如来了个人要做到第三个位置，那他只需要把自己的位置告诉第二个人，然后问第二个人拿到原来第三个人的位置就行了。其他人都不用动。
- 查找数据时效率低，因为不具有随机访问性，所以访问某个位置的数据都要从第一个数据开始访问，然后根据第一个数据保存的下一个数据的地址找到第二个数据，以此类推。 要找到第三个人，必须从第一个人开始问起。
- 不指定大小，扩展方便。链表大小不用定义，数据随意增删。


### 僵尸进程
一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。

在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。

它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid（）等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。

用命令ps，可以看到有标记为Z的进程就是僵尸进程。

### 排序算法稳定性

稳定性定义：

排序前后两个相等的数相对位置不变，则算法稳定。

稳定性得好处：

从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用

各排序算法的稳定性：

1、堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法；

2、基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法。


